<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ì»¤í…€ë¦¬ë“¬ í¸ì§‘ê¸°</title>
    <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Black+Han+Sans&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <!-- SoundCloud API -->
    <script src="https://w.soundcloud.com/player/api.js"></script>
    <style>
        body {
            background-color: #121212;
            color: white;
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        h1 { 
            margin: 5px 0; 
            font-family: 'Black Han Sans', sans-serif; 
            font-size: 28px; 
            letter-spacing: 2px;
            text-shadow: 0 0 10px #ff00de;
            background: linear-gradient(to right, #ff00de, #a800ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #editor-container {
            display: flex;
            width: 98%;
            height: 90%;
            gap: 10px;
        }

        .panel {
            background: #1e1e1e;
            border: 1px solid #333;
            border-radius: 10px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            overflow-y: auto;
        }

        #settings-panel { flex: 1; max-width: 300px; }
        #canvas-area {
            flex: 2;
            position: relative;
            background: #000;
            border: 2px solid #555;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        #timeline-panel { flex: 1; max-width: 300px; }

        .input-group { margin-bottom: 8px; }
        label { display: block; font-size: 12px; color: #888; margin-bottom: 3px; font-weight: bold; }
        input[type="text"], input[type="number"], select {
            width: 100%; background: #2a2a2a; border: 1px solid #444; color: white;
            padding: 8px; border-radius: 4px; box-sizing: border-box; font-family: 'Roboto Mono', monospace;
        }
        
        input[type="range"] { width: 100%; cursor: pointer; accent-color: #00d2ff; }

        button {
            width: 100%; padding: 10px; background: #333; color: #eee; border: none;
            border-radius: 5px; cursor: pointer; font-weight: bold; transition: 0.2s; margin-bottom: 5px;
        }
        button:hover { background: #444; }
        button.active { background: #00d2ff; color: #000; box-shadow: 0 0 10px #00d2ff; }
        button.record { background: #ff4d4d; color: white; }
        button.record.recording { background: #ff0000; animation: pulse 1s infinite; box-shadow: 0 0 15px red; }
        
        .btn-group { display: flex; gap: 5px; }
        button.file-btn { background: #555; font-size: 12px; padding: 8px; }
        button.save { background: linear-gradient(45deg, #00d2ff, #3a7bd5); margin-top: auto; }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }

        /* ë¯¸ë””ì–´ ì»¨í…Œì´ë„ˆ ìˆ¨ê¹€ */
        #media-hidden { 
            position: absolute; 
            left: -9999px; 
            top: 0;
            width: 300px; 
            height: 300px; 
            opacity: 0; 
            pointer-events: none; 
            overflow: hidden;
        }

        canvas { background: radial-gradient(circle, #222 0%, #000 100%); cursor: crosshair; }
        .info-text { font-size: 11px; color: #666; margin-top: 2px; }
        hr { border: 0; border-top: 1px solid #333; width: 100%; margin: 10px 0; }
        
        /* [ìˆ˜ì •] ì¬ìƒ ì»¨íŠ¸ë¡¤ ì˜ì—­ */
        #playback-controls {
            display: none; /* ì´ˆê¸°ì—ëŠ” ìˆ¨ê¹€ */
        }

        #time-display {
            font-family: 'Roboto Mono', monospace; font-size: 24px; text-align: center;
            color: #00d2ff; text-shadow: 0 0 5px rgba(0, 210, 255, 0.5); margin: 10px 0;
        }
        
        .key-guide {
            display: flex; justify-content: space-around; background: #222; padding: 5px; border-radius: 5px; margin-top: 5px;
        }
        .key-item { font-size: 11px; color: #aaa; text-align: center; }
        .key-item b { display: block; font-size: 13px; color: #fff; }
        
        #yt-status { font-size: 10px; color: #ff0000; margin-top: 2px; display: none; }
    </style>
</head>
<body>

    <h1>ğŸ›ï¸ ì»¤í…€ë¦¬ë“¬ í¸ì§‘ê¸° (6.0)</h1>

    <div id="editor-container">
        <!-- ì™¼ìª½: ì„¤ì • -->
        <div id="settings-panel" class="panel">
            <h3 style="margin:0; color:#ddd;">ğŸ“ ë§µ & íŒŒì¼</h3>
            
            <div class="input-group">
                <label>íŒŒì¼ ê´€ë¦¬</label>
                <div class="btn-group">
                    <button class="file-btn" onclick="document.getElementById('file-input').click()">ğŸ“‚ íŒŒì¼ ì—´ê¸° (.crn)</button>
                    <!-- [ìˆ˜ì •ë¨] ì´ë¦„ ì§€ì • ì €ì¥ì„ ìœ„í•´ onclick í•¨ìˆ˜ ìœ ì§€ -->
                    <button class="file-btn" onclick="downloadMapFile()">ğŸ’¾ ì €ì¥ (.crn)</button>
                </div>
                <input type="file" id="file-input" accept=".crn,.json" style="display: none;" onchange="loadMapFile(this)">
            </div>
            <hr>

            <div class="input-group">
                <label>ìŒì› ë§í¬ (YouTube/SoundCloud)<br>ì‚¬ìš´ë“œí´ë¼ìš°ë“œë¥¼ ê°•ë ¥ ì¶”ì²œí•©ë‹ˆë‹¤.</label>
                <input type="text" id="music-url" placeholder="URL ì…ë ¥ (ì˜ˆ: https://youtu.be/...)">
                <button onclick="loadMedia()" style="margin-top:5px;">ğŸµ ìŒì› ë¡œë“œ</button>
                <div id="yt-status">YouTube API ì¤€ë¹„ ì¤‘...</div>
            </div>
            <hr>
            <div class="input-group">
                <label>í‚¤ ëª¨ë“œ (Key Mode)</label>
                <select id="key-mode" onchange="changeKeyMode()">
                    <option value="2">2 Key (Basic)</option>
                    <option value="4">4 Key (Advanced)</option>
                    <option value="6">6 Key (Expert)</option>
                </select>
            </div>
            <div class="key-guide" id="key-guide-display"></div>
            <hr>
            <div class="input-group">
                <label>ì±„ë³´ ë°©í–¥ (Scroll)</label>
                <select id="scroll-direction" onchange="updateScrollDir()">
                    <option value="down" selected>Down (ìœ„â†’ì•„ë˜)</option>
                    <option value="up">Up (ì•„ë˜â†’ìœ„)</option>
                </select>
            </div>
            <!-- [ì¶”ê°€ë¨] ì±„ë³´ ì†ë„ ì¡°ì ˆ ìŠ¬ë¼ì´ë” -->
            <div class="input-group">
                <label>ë…¸íŠ¸ ì†ë„ (Speed): <span id="speed-display" style="color:#00d2ff">1.0</span>x</label>
                <input type="range" id="note-speed" min="0.5" max="3.0" step="0.1" value="1.0" oninput="updateSpeed()">
            </div>
            <div class="input-group">
                <label>BPM</label>
                <input type="number" id="bpm" value="120" onchange="updateGrid()">
            </div>
            <div class="input-group">
                <label>ì˜¤í”„ì…‹ (Offset)</label>
                <input type="number" id="offset" value="0.0" step="0.01" onchange="updateGrid()">
            </div>
            <div class="input-group">
                <label>ìŠ¤ëƒ… (Snap)</label>
                <select id="snap-divisor">
                    <option value="1">1/1</option>
                    <option value="2">1/2</option>
                    <option value="4" selected>1/4 (ê¶Œì¥)</option>
                    <option value="8">1/8</option>
                    <option value="0">í•´ì œ (Free)</option>
                </select>
            </div>
            
            <button class="save" onclick="exportToClipboard()">ğŸ“‹ ì½”ë“œ ë³µì‚¬ (í´ë¦½ë³´ë“œ)</button>
            <textarea id="export-area" style="height: 40px; resize: none; background:#111; color:#0f0; border:1px solid #444;" readonly placeholder="ì½”ë“œ ë³µì‚¬ ê²°ê³¼"></textarea>
        </div>

        <!-- ì¤‘ì•™: ìº”ë²„ìŠ¤ -->
        <div id="canvas-area">
            <canvas id="editorCanvas" width="450" height="700"></canvas>
            
            <div id="media-hidden">
                <div id="yt-player"></div>
                <iframe id="sc-player" width="100%" height="166" scrolling="no" frameborder="no" allow="autoplay; encrypted-media" 
                    src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/293&color=%23ff5500&auto_play=false&hide_related=true&show_comments=false&show_user=false&show_reposts=false&show_teaser=false&visual=false">
                </iframe>
            </div>
        </div>

        <!-- ì˜¤ë¥¸ìª½: ë„êµ¬ -->
        <div id="timeline-panel" class="panel">
            <h3 style="margin:0; color:#ddd;">ğŸ› ï¸ í¸ì§‘ & ë…¹í™”</h3>
            
            <!-- [ìˆ˜ì •] ì¬ìƒë°”ì™€ ì»¨íŠ¸ë¡¤ì„ ë¬¶ì–´ì„œ ì´ˆê¸°ì—ëŠ” ìˆ¨ê¹€ -->
            <div id="playback-controls">
                <div id="time-display">00:00.000</div>
                <div class="input-group">
                    <input type="range" id="seek-bar" min="0" max="100" step="0.1" value="0" 
                           onmousedown="startDraggingSlider()" 
                           onmouseup="finishDraggingSlider()" 
                           oninput="seeking()">
                </div>
                <button id="play-btn" onclick="togglePlay()">â–¶ ì¬ìƒ (Space)</button>
            </div>
            
            <!-- ìŒì›ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ì„ ë•Œ ë³´ì´ëŠ” ì•ˆë‚´ ë¬¸êµ¬ (ì„ íƒì‚¬í•­) -->
            <div id="no-media-msg" style="text-align:center; color:#666; font-size:12px; margin: 20px 0;">
                ì™¼ìª½ì—ì„œ ìŒì›ì„ ë¨¼ì € ë¡œë“œí•´ì£¼ì„¸ìš”.
            </div>

            <hr>
            <label>ğŸ”´ ì‹¤ì‹œê°„ ë…¹í™” (Live Record)</label>
            <button id="record-btn" class="record" onclick="toggleRecord()">âº ë…¹í™” ëª¨ë“œ ì¼œê¸°</button>
            <div class="info-text">
                <b>[2í‚¤]</b> D/K or ë§ˆìš°ìŠ¤ í´ë¦­<br>
                <b>[4í‚¤]</b> D/F / J/K<br>
                <b>[6í‚¤]</b> S/D/F / J/K/L
            </div>
            <hr>
            <label>ë§ˆìš°ìŠ¤ ë„êµ¬</label>
            <div style="display:flex; gap:5px;">
                <button id="tool-tap" class="active" onclick="setTool('tap')">ë‹¨íƒ€</button>
                <button id="tool-long" onclick="setTool('long')">ë¡±ë…¸íŠ¸</button>
                <button id="tool-del" onclick="setTool('delete')">ì§€ìš°ê°œ</button>
            </div>
            <div class="info-text" style="margin-top:10px;">
                * <b>ë¡±ë…¸íŠ¸:</b> ê¾¹ ëˆ„ë¥´ê³  ë“œë˜ê·¸í•˜ì—¬ ê¸¸ì´ ì¡°ì ˆ<br>
                * <b>íœ :</b> íƒ€ì„ë¼ì¸ ì´ë™ (Shift: ì •ë°€)<br>
                * <b>ìš°í´ë¦­:</b> ë…¸íŠ¸ ì‚­ì œ
            </div>
        </div>
    </div>

    <script>
        // --- ì „ì—­ ì„¤ì • ---
        let mapData = { v: 3, keyMode: 2, bpm: 120, offset: 0, notes: [] };
        
        let isPlaying = false;
        let isRecording = false; 
        let isDraggingSlider = false;
        let scrollDir = 'down';

        let currentTime = 0;
        let duration = 1; 
        let currentTool = 'tap'; 
        
        let HIT_LINE_Y = 550;
                const BASE_PIXELS_PER_SECOND = 400; // ê¸°ë³¸ ì†ë„ ìƒìˆ˜
                let pixelsPerSecond = 400;          // í˜„ì¬ ì ìš©ëœ ì†ë„ ë³€ìˆ˜
        const PIXELS_PER_SECOND = 400; 

        // ë¯¸ë””ì–´ ê´€ë ¨ ë³€ìˆ˜
        let ytPlayer = null;
        let isYTReady = false;
        let scWidget = null;
        let activeProvider = null; // 'youtube' or 'soundcloud'
        let scStartTime = 0; 
        let scPlayOffset = 0;

        let heldCols = {}; 
        let dragNote = null;

        const canvas = document.getElementById('editorCanvas');
        const ctx = canvas.getContext('2d');

        // í‚¤ ë§¤í•‘
        const KEY_MAPPING = {
            2: { 'KeyD': 0, 'KeyF': 0, 'KeyJ': 1, 'KeyK': 1 }, 
            4: { 'KeyD': 0, 'KeyF': 1, 'KeyJ': 2, 'KeyK': 3 },
            6: { 'KeyS': 0, 'KeyD': 1, 'KeyF': 2, 'KeyJ': 3, 'KeyK': 4, 'KeyL': 5 }
        };

        // --- YouTube API ì´ˆê¸°í™” ---
        function loadYoutubeAPI() {
            var tag = document.createElement('script');
            tag.src = "https://www.youtube.com/iframe_api";
            var firstScriptTag = document.getElementsByTagName('script')[0];
            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        }

        window.onYouTubeIframeAPIReady = function() {
            ytPlayer = new YT.Player('yt-player', {
                height: '200',
                width: '200',
                playerVars: { 
                    'controls': 0, 
                    'disablekb': 1,
                    'playsinline': 1,
                    'origin': window.location.origin 
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange,
                    'onError': onPlayerError
                }
            });
        };

        function onPlayerReady(event) {
            isYTReady = true;
            document.getElementById('yt-status').style.display = 'none';
            console.log("YouTube Player Ready");
        }

        function onPlayerError(event) {
            console.error("YouTube Player Error:", event.data);
            alert("YouTube ì¬ìƒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ (ìœ íš¨í•˜ì§€ ì•Šì€ ì˜ìƒ ID ë“±)");
        }

        // --- ì´ˆê¸°í™” ---
        window.onload = () => {
            loadYoutubeAPI();

            const iframe = document.getElementById('sc-player');
            scWidget = SC.Widget(iframe);
            
            scWidget.bind(SC.Widget.Events.PLAY, () => {
                scStartTime = Date.now();
                scWidget.getPosition((p) => scPlayOffset = p / 1000);
            });
            scWidget.bind(SC.Widget.Events.SEEK, () => {
                scWidget.getPosition((p) => {
                    scPlayOffset = p / 1000;
                    scStartTime = Date.now();
                });
            });
            scWidget.bind(SC.Widget.Events.PAUSE, () => { isPlaying = false; updatePlayBtn(); });
            scWidget.bind(SC.Widget.Events.FINISH, () => { isPlaying = false; updatePlayBtn(); });
            scWidget.bind(SC.Widget.Events.READY, () => {
                console.log("SoundCloud Widget Ready");
            });

            updateKeyGuide();
            updateScrollDir();
            requestAnimationFrame(drawLoop);
        };

        // --- ë¯¸ë””ì–´ ë¡œì§ & UI ì œì–´ ---
        function enableControls() {
            document.getElementById('playback-controls').style.display = 'block';
            document.getElementById('no-media-msg').style.display = 'none';
        }

function loadMedia() {
            const url = document.getElementById('music-url').value.trim();
            if (!url) { alert("URLì„ ì…ë ¥í•´ì£¼ì„¸ìš”."); return; }

            pauseAll();

            if (url.includes('youtu')) {
                const id = getYoutubeId(url);
                if(id) {
                    if (!isYTReady || !ytPlayer) {
                        alert("YouTube í”Œë ˆì´ì–´ê°€ ì•„ì§ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.");
                        document.getElementById('yt-status').style.display = 'block';
                        return;
                    }
                    activeProvider = 'youtube';
                    ytPlayer.loadVideoById(id);
                    ytPlayer.pauseVideo();
                    
                    enableControls();

                    setTimeout(() => {
                        if(ytPlayer && ytPlayer.getDuration) {
                            duration = ytPlayer.getDuration();
                            document.getElementById('seek-bar').max = duration;
                            document.getElementById('seek-bar').value = 0;
                            currentTime = 0;
                        }
                    }, 1500);
                } else {
                    alert("ì˜¬ë°”ë¥´ì§€ ì•Šì€ YouTube URLì…ë‹ˆë‹¤.");
                }
            } else if (url.includes('soundcloud')) {
                activeProvider = 'soundcloud';
                
                // [ì¤‘ìš”] ê¸°ì¡´ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆê°€ ê³„ì† ìŒ“ì´ëŠ” ê²ƒì„ ë°©ì§€í•˜ê¸° ìœ„í•´ ì´ˆê¸°í™”
                scWidget.unbind(SC.Widget.Events.READY);

                scWidget.load(url, { 
                    auto_play: true, // [í•µì‹¬ ìˆ˜ì •] trueë¡œ ì„¤ì •í•˜ì—¬ ì˜¤ë””ì˜¤ ì—”ì§„ì„ ê°•ì œ í™œì„±í™”
                    visual: false,
                    show_artwork: false 
                });
                
                enableControls();

                // ë¡œë“œê°€ ì™„ë£Œ(READY)ë˜ë©´ ì¦‰ì‹œ ë©ˆì¶°ì„œ ì‚¬ìš©ìì—ê²ŒëŠ” ì •ì§€ëœ ê²ƒì²˜ëŸ¼ ë³´ì´ê²Œ í•¨
                scWidget.bind(SC.Widget.Events.READY, () => {
                    // ì†Œë¦¬ í™•ë³´ë¥¼ ìœ„í•´ ë³¼ë¥¨ì„ í™•ì‹¤íˆ ì„¤ì •
                    scWidget.setVolume(100);
                    
                    // auto_play: trueë¡œ ì¸í•´ ì‹œì‘ëœ ì¬ìƒì„ ì¦‰ì‹œ ë©ˆì¶¤
                    scWidget.pause();
                    scWidget.seekTo(0);
                    
                    isPlaying = false;
                    updatePlayBtn();

                    scWidget.getDuration(d => {
                        duration = d / 1000;
                        document.getElementById('seek-bar').max = duration;
                        document.getElementById('seek-bar').value = 0;
                        currentTime = 0;
                    });
                });
            } else {
                alert("ì§€ì›ë˜ì§€ ì•ŠëŠ” URLì…ë‹ˆë‹¤. (YouTube ë˜ëŠ” SoundCloudë§Œ ê°€ëŠ¥)");
            }
        }

        function getYoutubeId(url) {
            const match = url.match(/^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/);
            return (match && match[2].length === 11) ? match[2] : null;
        }

        function pauseAll() {
            isPlaying = false;
            updatePlayBtn();
            if (ytPlayer && typeof ytPlayer.pauseVideo === 'function') ytPlayer.pauseVideo();
            if (scWidget) scWidget.pause();
        }

        function togglePlay() {
            if (activeProvider === null) {
                alert("ë¨¼ì € ìŒì›ì„ ë¡œë“œí•´ì£¼ì„¸ìš”.");
                return;
            }

            if (isPlaying) {
                pauseAll();
            } else {
                if (activeProvider === 'youtube') {
                    if(ytPlayer && typeof ytPlayer.playVideo === 'function') {
                        ytPlayer.playVideo();
                    } else {
                        return;
                    }
                } else if (activeProvider === 'soundcloud') {
                    scWidget.play();
                    scStartTime = Date.now();
                }
                isPlaying = true;
                updatePlayBtn();
            }
        }

        function onPlayerStateChange(event) {
            if (event.data == YT.PlayerState.PLAYING) {
                isPlaying = true;
                duration = ytPlayer.getDuration();
                document.getElementById('seek-bar').max = duration;
            }
            else if (event.data == YT.PlayerState.PAUSED || event.data == YT.PlayerState.ENDED) {
                isPlaying = false;
            }
            updatePlayBtn();
        }

        function updatePlayBtn() {
            document.getElementById('play-btn').innerText = isPlaying ? "â¸ ì¼ì‹œì •ì§€ (Space)" : "â–¶ ì¬ìƒ (Space)";
        }

        // --- ìŠ¬ë¼ì´ë” ì»¨íŠ¸ë¡¤ ---
        function startDraggingSlider() { 
            isDraggingSlider = true; 
        }
        
        function seeking() {
            const val = parseFloat(document.getElementById('seek-bar').value);
            currentTime = val;
            updateTimeDisplay();
        }
        
        function finishDraggingSlider() {
            isDraggingSlider = false;
            const val = parseFloat(document.getElementById('seek-bar').value);
            currentTime = val;
            
            if (activeProvider === 'youtube' && ytPlayer && isYTReady) {
                ytPlayer.seekTo(val, true);
            }
            if (activeProvider === 'soundcloud') {
                scWidget.seekTo(val * 1000);
            }
        }
        
        // [ì¶”ê°€ë¨] ì†ë„ ì¡°ì ˆ í•¨ìˆ˜
        function updateSpeed() {
            const val = parseFloat(document.getElementById('note-speed').value);
            document.getElementById('speed-display').innerText = val.toFixed(1);
            pixelsPerSecond = BASE_PIXELS_PER_SECOND * val;
        }
        
        function updateScrollDir() {
            scrollDir = document.getElementById('scroll-direction').value;
            HIT_LINE_Y = scrollDir === 'down' ? 550 : 150;
        }

        // --- ë©”ì¸ ë£¨í”„ (ë Œë”ë§) ---
        function drawLoop() {
            if (isPlaying && !isDraggingSlider) {
                if (activeProvider === 'youtube' && isYTReady && ytPlayer && ytPlayer.getCurrentTime) {
                    try {
                        const t = ytPlayer.getCurrentTime();
                        if(typeof t === 'number') currentTime = t;
                    } catch(e) { /* ë¬´ì‹œ */ }
                } else if (activeProvider === 'soundcloud') {
                    currentTime = scPlayOffset + (Date.now() - scStartTime) / 1000;
                    if (currentTime > duration) currentTime = duration;
                }
                document.getElementById('seek-bar').value = currentTime;
            }
            
            if (!isDraggingSlider) updateTimeDisplay();

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const laneCount = mapData.keyMode;
            const laneWidth = canvas.width / laneCount;
            
            // ë ˆì¸ êµ¬ë¶„ì„ 
            ctx.strokeStyle = '#333'; ctx.lineWidth = 1;
            for(let i=1; i<laneCount; i++) {
                ctx.beginPath(); ctx.moveTo(i * laneWidth, 0); ctx.lineTo(i * laneWidth, canvas.height); ctx.stroke();
            }

            // ë…¹í™” í‘œì‹œ
            if (isRecording && isPlaying) {
                ctx.save();
                ctx.fillStyle = "rgba(255, 0, 0, 0.15)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = "#ff3333";
                ctx.font = "bold 32px 'Black Han Sans', sans-serif";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.shadowBlur = 10;
                ctx.shadowColor = "red";
                ctx.fillText("â— RECORDING", canvas.width / 2, 80);
                ctx.restore();
            }

            // ê·¸ë¦¬ë“œ
            const bpm = mapData.bpm;
            const offset = mapData.offset;
            const snapDivisor = parseInt(document.getElementById('snap-divisor').value);
            
            let timeTop, timeBottom;
            if (scrollDir === 'down') {
                timeTop = currentTime + (HIT_LINE_Y / pixelsPerSecond); // ìˆ˜ì •ë¨
                timeBottom = currentTime - ((canvas.height - HIT_LINE_Y) / pixelsPerSecond); // ìˆ˜ì •ë¨
            } else {
                timeTop = currentTime - (HIT_LINE_Y / pixelsPerSecond); // ìˆ˜ì •ë¨
                timeBottom = currentTime + ((canvas.height - HIT_LINE_Y) / pixelsPerSecond); // ìˆ˜ì •ë¨
            }

            if (snapDivisor > 0 && bpm > 0) {
                const gridInterval = (60 / bpm) / snapDivisor;
                const minT = Math.min(timeTop, timeBottom);
                const maxT = Math.max(timeTop, timeBottom);
                
                const startGrid = Math.floor(Math.max(0, minT) / gridInterval);
                const endGrid = Math.ceil(maxT / gridInterval);

                ctx.font = "10px Roboto Mono";
                ctx.textAlign = "right";

                for(let i = startGrid; i <= endGrid; i++) {
                    const t = i * gridInterval + offset;
                    let y;
                    if (scrollDir === 'down') y = HIT_LINE_Y - (t - currentTime) * pixelsPerSecond; // ìˆ˜ì •ë¨
                    else y = HIT_LINE_Y + (t - currentTime) * pixelsPerSecond; // ìˆ˜ì •ë¨

                    const isBeat = (i % snapDivisor === 0);
                    const isMeasure = (i % (snapDivisor * 4) === 0);

                    ctx.strokeStyle = isBeat ? '#666' : '#222';
                    ctx.lineWidth = isBeat ? 2 : 1;
                    
                    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();

                    if (isMeasure) {
                         const mm = Math.floor(t / 60);
                         const ss = Math.floor(t % 60);
                         const timeText = `${mm}:${String(ss).padStart(2,'0')}`;
                         ctx.fillStyle = "#aaa";
                         ctx.fillText(timeText, 35, y - 2);
                    }
                }
            }

            // íŒì •ì„ 
            ctx.strokeStyle = '#00d2ff'; ctx.lineWidth = 3;
            ctx.shadowBlur = 10; ctx.shadowColor = '#00d2ff';
            ctx.beginPath(); ctx.moveTo(0, HIT_LINE_Y); ctx.lineTo(canvas.width, HIT_LINE_Y); ctx.stroke();
            ctx.shadowBlur = 0;

            // ë…¸íŠ¸
            mapData.notes.forEach(note => {
                const minT = Math.min(timeTop, timeBottom);
                const maxT = Math.max(timeTop, timeBottom);
                if (note.time > maxT + 2 || note.time + note.duration < minT - 1) return;

                let y;
                if (scrollDir === 'down') y = HIT_LINE_Y - (note.time - currentTime) * pixelsPerSecond; // ìˆ˜ì •ë¨
                else y = HIT_LINE_Y + (note.time - currentTime) * pixelsPerSecond; // ìˆ˜ì •ë¨
                
                const x = note.col * laneWidth;
                
                let color = '#fff';
                if (mapData.keyMode === 4) color = (note.col === 0 || note.col === 3) ? '#ff4d4d' : '#4d4dff';
                else if (mapData.keyMode === 6) {
                    if (note.col === 0 || note.col === 5) color = '#ff4d4d';
                    else if (note.col === 1 || note.col === 4) color = '#4d4dff';
                    else color = '#ffd700'; 
                }
                else color = (note.col === 0) ? '#ff4d4d' : '#4d4dff';

                if (note.duration > 0) {
                    const tailHeight = note.duration * pixelsPerSecond; // ìˆ˜ì •ë¨
                    let tailY;
                    if (scrollDir === 'down') tailY = y - tailHeight;
                    else tailY = y; 

                    ctx.fillStyle = color; ctx.globalAlpha = 0.4;
                    if (scrollDir === 'down') ctx.fillRect(x + 5, tailY + 10, laneWidth - 10, tailHeight);
                    else ctx.fillRect(x + 5, y + 10, laneWidth - 10, tailHeight);
                    ctx.globalAlpha = 1.0;
                }
                
                ctx.fillStyle = color; ctx.beginPath();
                ctx.roundRect(x + 2, y, laneWidth - 4, 20, 4); ctx.fill();
            });

            // Ghost Note
            if (dragNote) {
                let y;
                if (scrollDir === 'down') y = HIT_LINE_Y - (dragNote.startTime - currentTime) * pixelsPerSecond; // ìˆ˜ì •ë¨
                else y = HIT_LINE_Y + (dragNote.startTime - currentTime) * pixelsPerSecond; // ìˆ˜ì •ë¨

                const mouseTime = getTimeFromY(lastMouseY);
                let dur = Math.abs(mouseTime - dragNote.startTime);
                if(dur < 0) dur = 0;
                
                const tailHeight = dur * pixelsPerSecond; // ìˆ˜ì •ë¨
                const x = dragNote.col * laneWidth;

                ctx.fillStyle = "rgba(0, 255, 0, 0.5)";
                if (scrollDir === 'down') {
                     if (mouseTime > dragNote.startTime) ctx.fillRect(x + 5, y - tailHeight, laneWidth - 10, tailHeight);
                     else ctx.fillRect(x + 5, y, laneWidth - 10, tailHeight);
                } else {
                     if (mouseTime > dragNote.startTime) ctx.fillRect(x + 5, y, laneWidth - 10, tailHeight);
                     else ctx.fillRect(x + 5, y - tailHeight, laneWidth - 10, tailHeight);
                }
                ctx.fillRect(x + 2, y, laneWidth - 4, 20); 
            }

            requestAnimationFrame(drawLoop);
        }

        // --- ì…ë ¥ ì²˜ë¦¬ ---
        let lastMouseY = 0;
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            lastMouseY = e.clientY - rect.top;
        });

        function getTimeFromY(y) {
            if (scrollDir === 'down') {
                return currentTime + (HIT_LINE_Y - y) / pixelsPerSecond; // ìˆ˜ì •ë¨
            } else {
                return currentTime + (y - HIT_LINE_Y) / pixelsPerSecond; // ìˆ˜ì •ë¨
            }
        }

        canvas.addEventListener('mousedown', (e) => {
            if (isPlaying && !isRecording) return; 
            if (isRecording && isPlaying) return;

            const rect = canvas.getBoundingClientRect();
            const clickY = e.clientY - rect.top;
            const clickX = e.clientX - rect.left;
            
            let time = getTimeFromY(clickY);
            const col = Math.floor(clickX / (canvas.width / mapData.keyMode));

            const snapDivisor = parseInt(document.getElementById('snap-divisor').value);
            if (snapDivisor > 0 && mapData.bpm > 0) {
                const interval = (60 / mapData.bpm) / snapDivisor;
                time = Math.round((time - mapData.offset) / interval) * interval + mapData.offset;
            }

            if (e.button === 2 || currentTool === 'delete') {
                const idx = mapData.notes.findIndex(n => n.col === col && Math.abs(n.time - time) < 0.05);
                if(idx !== -1) mapData.notes.splice(idx, 1);
            } 
            else if (e.button === 0) {
                if (currentTool === 'tap') {
                    addNote(time, col, 0);
                }
                else if (currentTool === 'long') {
                    dragNote = { col: col, startTime: time, startY: clickY };
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (dragNote) {
                const rect = canvas.getBoundingClientRect();
                const clickY = e.clientY - rect.top;
                let endTime = getTimeFromY(clickY);

                const snapDivisor = parseInt(document.getElementById('snap-divisor').value);
                if (snapDivisor > 0 && mapData.bpm > 0) {
                    const interval = (60 / mapData.bpm) / snapDivisor;
                    endTime = Math.round((endTime - mapData.offset) / interval) * interval + mapData.offset;
                }

                const startTime = Math.min(dragNote.startTime, endTime);
                const finalEnd = Math.max(dragNote.startTime, endTime);
                let duration = finalEnd - startTime;

                if (duration < 0.01) duration = 0;
                addNote(startTime, dragNote.col, duration);
                dragNote = null;
            }
        });

        canvas.addEventListener('wheel', (e) => {
            if(isPlaying) return;
            e.preventDefault();
            const delta = (e.deltaY > 0 ? 1 : -1) * (e.shiftKey ? 0.05 : 0.5);
            let newTime = currentTime + delta;
            if(newTime < 0) newTime = 0;
            if(newTime > duration) newTime = duration;
            currentTime = newTime;
            document.getElementById('seek-bar').value = currentTime;
            updateTimeDisplay();
            
            if(activeProvider === 'youtube' && ytPlayer) ytPlayer.seekTo(currentTime, true);
            if(activeProvider === 'soundcloud') scWidget.seekTo(currentTime * 1000);
        }, { passive: false });

        function handleInputDown(col) {
            if (!isRecording || !isPlaying) return;
            if (heldCols[col] !== undefined) return;
            heldCols[col] = currentTime;
        }

        function handleInputUp(col) {
            if (!isRecording || !isPlaying) {
                if(heldCols[col] !== undefined) delete heldCols[col];
                return;
            }
            const startTime = heldCols[col];
            if (startTime !== undefined) {
                let duration = currentTime - startTime;
                if (duration < 0.1) duration = 0; 
                let finalTime = startTime;
                
                const snapDivisor = parseInt(document.getElementById('snap-divisor').value);
                if (snapDivisor > 0 && mapData.bpm > 0) {
                    const beatInt = (60 / mapData.bpm) / snapDivisor;
                    finalTime = Math.round((startTime - mapData.offset) / beatInt) * beatInt + mapData.offset;
                }
                addNote(finalTime, col, duration);
                delete heldCols[col];
            }
        }

        window.addEventListener('keydown', e => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            if (e.code === 'Space') { e.preventDefault(); togglePlay(); return; }
            if (e.repeat) return;
            const col = KEY_MAPPING[mapData.keyMode][e.code];
            if (col !== undefined) handleInputDown(col);
        });

        window.addEventListener('keyup', e => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            const col = KEY_MAPPING[mapData.keyMode][e.code];
            if (col !== undefined) handleInputUp(col);
        });

        window.addEventListener('mousedown', e => {
            if (e.target.closest('.panel')) return;
            if (isRecording && isPlaying && mapData.keyMode === 2) {
                if (e.button === 0) handleInputDown(0);
                if (e.button === 2) handleInputDown(1);
            }
        });
        window.addEventListener('mouseup', e => {
            if (isRecording && isPlaying && mapData.keyMode === 2) {
                if (e.button === 0) handleInputUp(0);
                if (e.button === 2) handleInputUp(1);
            }
        });
        window.addEventListener('contextmenu', e => {
            if(e.target === canvas) e.preventDefault();
        });

        function toggleRecord() {
            isRecording = !isRecording;
            const btn = document.getElementById('record-btn');
            if (isRecording) {
                btn.classList.add('recording');
                btn.innerText = "â¹ ë…¹í™” ì¤‘ì§€";
            } else {
                btn.classList.remove('recording');
                btn.innerText = "âº ë…¹í™” ëª¨ë“œ ì¼œê¸°";
                heldCols = {}; 
            }
        }

        function addNote(time, col, duration) {
            const existing = mapData.notes.find(n => n.col === col && Math.abs(n.time - time) < 0.02);
            if (existing) {
                existing.duration = duration;
            } else {
                mapData.notes.push({ 
                    time: parseFloat(time.toFixed(3)), 
                    col, 
                    duration: parseFloat(duration.toFixed(3)) 
                });
            }
        }

        function changeKeyMode() {
            if(mapData.notes.length > 0 && !confirm("í‚¤ ëª¨ë“œë¥¼ ë³€ê²½í•˜ë©´ ê¸°ì¡´ ë…¸íŠ¸ê°€ ì´ˆê¸°í™”ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
                document.getElementById('key-mode').value = mapData.keyMode;
                return;
            }
            mapData.keyMode = parseInt(document.getElementById('key-mode').value);
            mapData.notes = [];
            updateKeyGuide();
        }

        function updateKeyGuide() {
            const el = document.getElementById('key-guide-display');
            const mode = mapData.keyMode;
            if (mode === 2) el.innerHTML = `<div class="key-item">Left<b>D</b></div><div class="key-item">Right<b>K</b></div>`;
            else if (mode === 4) el.innerHTML = `<div class="key-item">1<b>D</b></div><div class="key-item">2<b>F</b></div><div class="key-item">3<b>J</b></div><div class="key-item">4<b>K</b></div>`;
            else if (mode === 6) el.innerHTML = `<div class="key-item">1<b>S</b></div><div class="key-item">2<b>D</b></div><div class="key-item">3<b>F</b></div><div class="key-item">4<b>J</b></div><div class="key-item">5<b>K</b></div><div class="key-item">6<b>L</b></div>`;
        }
        
        function setTool(tool) {
            currentTool = tool;
            ['tap','long','delete'].forEach(t => document.getElementById(`tool-${t}`).classList.remove('active'));
            document.getElementById(`tool-${tool}`).classList.add('active');
        }

        function updateTimeDisplay() {
            const m = Math.floor(currentTime / 60);
            const s = Math.floor(currentTime % 60);
            const ms = Math.floor((currentTime % 1) * 1000);
            document.getElementById('time-display').innerText = 
                `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(ms).padStart(3,'0')}`;
        }
        
        function updateGrid() {
            mapData.bpm = parseFloat(document.getElementById('bpm').value) || 120;
            mapData.offset = parseFloat(document.getElementById('offset').value) || 0;
        }

        // --- ë‚´ë³´ë‚´ê¸°/ë¶ˆëŸ¬ì˜¤ê¸° ê¸°ëŠ¥ ---

        function generateExportData() {
            mapData.notes.sort((a,b) => a.time - b.time);
            
            const compressedNotes = mapData.notes.map(n => {
                const t = parseFloat(n.time.toFixed(3));
                const c = n.col;
                const d = parseFloat(n.duration.toFixed(3));
                return d > 0 ? [t, c, d] : [t, c];
            });

            // í˜„ì¬ ìŠ¬ë¼ì´ë”ì˜ ì†ë„ ê°’ì„ ê°€ì ¸ì˜´
            const currentSpeed = parseFloat(document.getElementById('note-speed').value);

            return {
                v: 3,
                url: document.getElementById('music-url').value,
                keyMode: mapData.keyMode,
                bpm: mapData.bpm,
                offset: mapData.offset,
                speed: currentSpeed, // [ì¶”ê°€ë¨] ì—¬ê¸°ì— ì†ë„ ì €ì¥
                d: compressedNotes
            };
        }

        function exportToClipboard() {
            const data = generateExportData();
            const str = JSON.stringify(data);
            const textArea = document.getElementById('export-area');
            textArea.value = str;
            textArea.select();
            document.execCommand('copy');
            alert("ì½”ë“œê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!");
        }

        // [ìˆ˜ì •] íŒŒì¼ ì´ë¦„ ì§€ì • ê¸°ëŠ¥ ì¶”ê°€
        function downloadMapFile() {
            // ì‚¬ìš©ìë¡œë¶€í„° íŒŒì¼ ì´ë¦„ ì…ë ¥ ë°›ê¸°
            let filename = prompt("ì €ì¥í•  íŒŒì¼ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:", "custom_rhythm");
            
            // ì·¨ì†Œ ë²„íŠ¼ì„ ëˆŒë €ì„ ê²½ìš° í•¨ìˆ˜ ì¢…ë£Œ
            if (filename === null) return;
            
            // ì´ë¦„ì´ ë¹„ì–´ìˆìœ¼ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©
            if (filename.trim() === "") filename = "custom_rhythm";
            
            // í™•ì¥ì .crn í™•ì¸ ë° ì¶”ê°€
            if (!filename.endsWith(".crn")) filename += ".crn";

            const data = generateExportData();
            const jsonStr = JSON.stringify(data);
            const blob = new Blob([jsonStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename; // ì…ë ¥ë°›ì€ íŒŒì¼ ì´ë¦„ ì‚¬ìš©
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function loadMapFile(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const loadedData = JSON.parse(e.target.result);
                    if (!loadedData.d) throw new Error("ìœ íš¨í•˜ì§€ ì•Šì€ íŒŒì¼ì…ë‹ˆë‹¤.");

                    document.getElementById('music-url').value = loadedData.url || "";
                    document.getElementById('key-mode').value = loadedData.keyMode || 2;
                    document.getElementById('bpm').value = loadedData.bpm || 120;
                    document.getElementById('offset').value = loadedData.offset || 0;

                    // [ì¶”ê°€ë¨] ì†ë„ ë¶ˆëŸ¬ì˜¤ê¸° ë¡œì§
                    // íŒŒì¼ì— ì†ë„ ì •ë³´ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ 1.0 ì‚¬ìš©
                    const savedSpeed = loadedData.speed || 1.0; 
                    document.getElementById('note-speed').value = savedSpeed;
                    
                    // [ì¤‘ìš”] ë¶ˆëŸ¬ì˜¨ ê°’ìœ¼ë¡œ ì‹¤ì œ ë³€ìˆ˜ ì—…ë°ì´íŠ¸ ë° UI í…ìŠ¤íŠ¸ ê°±ì‹ 
                    // (ì´ì „ì— ë§Œë“  updateSpeed í•¨ìˆ˜ë¥¼ ì§ì ‘ í˜¸ì¶œí•˜ê±°ë‚˜ ì•„ë˜ì²˜ëŸ¼ ë¡œì§ ìˆ˜í–‰)
                    document.getElementById('speed-display').innerText = savedSpeed.toFixed(1);
                    pixelsPerSecond = BASE_PIXELS_PER_SECOND * savedSpeed;


                    mapData.keyMode = loadedData.keyMode || 2;
                    mapData.bpm = loadedData.bpm || 120;
                    mapData.offset = loadedData.offset || 0;
                    
                    mapData.notes = loadedData.d.map(arr => ({
                        time: arr[0],
                        col: arr[1],
                        duration: arr[2] || 0
                    }));

                    updateKeyGuide();
                    alert("íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸° ì„±ê³µ!");
                    
                    if (loadedData.url) loadMedia();

                } catch (err) {
                    alert("íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: " + err.message);
                }
            };
            reader.readAsText(file);
            input.value = ""; 
        }
    </script>
</body>
</html>